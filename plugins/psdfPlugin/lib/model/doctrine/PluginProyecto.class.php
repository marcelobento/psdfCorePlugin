<?php

/**
 * PluginProyecto
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    ##PACKAGE##
 * @subpackage ##SUBPACKAGE##
 * @author     ##NAME## <##EMAIL##>
 * @version    SVN: $Id: Builder.php 6820 2009-11-30 17:27:49Z jwage $
 */
abstract class PluginProyecto extends BaseProyecto
{
  /**
   * Recupera la ruta dentro del workspace donde se alojan los xpdl
   * No incluye la ruta del workspace.
   * Por ej. 'proyecto/Process' si se alojan en [workspacedir]/proyecto/Process
   * Utilizado para la Exportación e Importación de un workspace
   * @return string subpath
   */
  public function getSubPathInWorkspace() {
      return 'proyecto'.DIRECTORY_SEPARATOR.'Process Packages';
  }

  /**
   * Construccion de un workspace con los paquetes del proyecto
   * @param $pPath       Ruta destino del workspace (debe tener permisos de escritura)
   * @return unknown_type
   */
  public function generateWorkspace( $pPath )
  {
    // Genero estructura de directorios
    $arguments['wspath'] = $pPath;
    $arguments['pkpath'] = $this->getSubPathInWorkspace();
    $arguments['packages'] = $this->getPaquetesAExportar();
    $options = array();

    $ws = new psdfGenerateWorkspace();
    $ws->execute($arguments, $options);
  }

  /**
   * Recupero una lista con los nombres, xpdl y macro de paquetes a exportar para
   * trabajarlo localmente.
   * Aquí deberían agregarse los filtros necesarios para no traer todos.
   * @return array Lista de paquetes (nombre y xpdl)
   */
  public function getPaquetesAExportar()
  {
    $packs = Doctrine_Core::getTable('Paquete')->findByProyecto($this->getId());
    $list=array();
    $key=-1;
    foreach( $packs as $pack)
    {
        $key++;
        $list[$key]['name'] = $pack->getNombre();
        $list[$key]['xpdl'] = $pack->getXpdl();
        $list[$key]['macro'] = $pack->getMacro()->getNombre();
    }
    return $list;
  }

/**
 * Procesa un workspace importando los archivos xpdls seleccionados.
 * Retorna un array con los archivos que no pudieron ser procesados.
 * @param string $pPath Ruta del workspace
 * @param array $pFiles Archivos Xpdls a Importar
 * @return array Archivos no procesados
 */
public function processWorkspace( $pPath, $pFiles ) {

    // Para ir volcando los paquetes no procesados por alguna regla invalida
    $noimp = array();
    
    foreach( $pFiles as $file ) {

        $full_path_xpdl = $pPath.DIRECTORY_SEPARATOR.
                            $this->getSubPathInWorkspace().DIRECTORY_SEPARATOR.$file;

        $xpdl = new Xpdl( $full_path_xpdl );

        // Recupero Id y Nombre del paquete
        $xpdlPackageId = $xpdl->getPackageId();
        $xpdlPackageName = $xpdl->getPackageName();

        // Recupero relaciones con Objeto Paquete y Macro del PSDF
        // (si ya fué importado anteriormente sinó vendrá como nulo
        $paquete_id = $xpdl->getPsdfPaquete();
        $macro_id = $xpdl->getPsdfMacro();
        $macro_name = $xpdl->getPsdfMacroName();
        if( $macro_name==null ) {
            $macro_name = $xpdl->determineMacroName();
        }

        // Todo el xpdl como un string para guardarlo
        $content = $xpdl->getContent();

        // Intento recuperar Macro y Paquete si ya estuviesen almacenados
        $macro = Doctrine::getTable('Macro')->findOneByNombre($macro_name);
        $pack = Doctrine::getTable('Paquete')->findOneByXpdlId($xpdlPackageId);

        // REGLAS

        $err = array();

        if( $pack ) {
            if( $pack->getId() != $paquete_id ) {
                $err['file'] = $file;
                $err['error'] = 'Ya existe el Paquete '.$xpdlPackageName.' pero no coinciden los ids';
            }
        }

        // CONTINUO SI SE PASARON TODAS LAS REGLAS

        if( count($err)==0 ) {
            // Creo el macro si aún no existe
            if( !$macro ) {
                $macro = new Macro();
                $macro->setNombre($macro_name);
                $macro->setRelProyecto( $this->getId() );
            }
            else {
                // Actualizo el nombre del Macro si fuese cambiado
                if( $macro->getNombre()!=$macro_name ) {
                    $macro->setNombre($macro_name);
                }
            }
            if( $macro->isNew() or $macro->isModified() ) {
                $macro->save();
            }


            // Creo el paquete si aún no existe y actualizo
            if( !$pack ) {
                $pack = new Paquete();
                $pack->setNombre($xpdlPackageName);
                $pack->setRelMacro($macro->getId());
                $pack->setXpdl($content);
                $pack->setXpdlId($xpdlPackageId);
                $pack->save(); // Grabo para que genere el Id
            }
            else {
                if( $pack->getXpdl()!=$content ) {
                    $pack->setXpdl($content);
                }
                if( $pack->getNombre()!=$xpdlPackageName ) {
                    $pack->setNombre($xpdlPackageName);
                }
            }
            // Genero/Actualizo relaciones xpdl con psdf
            $pack->setPsdfDataInXpdl( $pack->getId(), $macro->getId(), $macro->getNombre() );

            if( $pack->isNew() or $pack->isModified() ) {
                // Sincronizo procesos (seteos ids en xpdl y objetos)
                $ret = $pack->syncProcess();
                if( count($err)>0 ) {
                    $noimp[] = array_merge($noimp, $ret);
                }
                // Guardo el paquete con los cambios
                $pack->save();
                // Guardo el archivo con los ids seteados
                file_put_contents( $full_path_xpdl, $pack->xpdl->getContent() );
            }
        }
        else {
            $noimp[] = $err;
        }
    }
    return $noimp;
}


}