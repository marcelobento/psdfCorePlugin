<?php

/**
 * PluginProyecto
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    ##PACKAGE##
 * @subpackage ##SUBPACKAGE##
 * @author     ##NAME## <##EMAIL##>
 * @version    SVN: $Id: Builder.php 6820 2009-11-30 17:27:49Z jwage $
 */
abstract class PluginProyecto extends BaseProyecto
{
  /**
   * Recupera la ruta dentro del workspace donde se alojan los xpdl
   * No incluye la ruta del workspace.
   * Por ej. 'proyecto/Process' si se alojan en [workspacedir]/proyecto/Process
   * Utilizado para la Exportación e Importación de un workspace
   * @return string subpath
   */
  public function getSubPathInWorkspace() {
      return 'proyecto'.DIRECTORY_SEPARATOR.'Process Packages';
  }

  /**
   * Construccion de un workspace con los paquetes del proyecto
   * @param $pPath       Ruta destino del workspace (debe tener permisos de escritura)
   * @return unknown_type
   */
  public function generateWorkspace( $pPath )
  {
    // Genero estructura de directorios
    $arguments['wspath'] = $pPath;
    $arguments['pkpath'] = $this->getSubPathInWorkspace();
    $arguments['packages'] = $this->getPaquetesAExportar();
    $options = array();

    $ws = new psdfGenerateWorkspace();
    $ws->execute($arguments, $options);
  }

  /**
   * Recupero una lista con los nombres, xpdl y macro de paquetes a exportar para
   * trabajarlo localmente.
   * Aquí deberían agregarse los filtros necesarios para no traer todos.
   * @return array Lista de paquetes (nombre y xpdl)
   */
  public function getPaquetesAExportar()
  {
    $packs = Doctrine_Core::getTable('Paquete')->getPaquetesByProyecto($this->getId());
    $list=array();
    $key=-1;
    foreach( $packs as $pack)
    {
        $key++;
        $list[$key]['name'] = $pack->getNombre();
        $list[$key]['xpdl'] = $pack->getXpdl();
        $list[$key]['macro'] = $pack->getNombreMacroPaquete();
    }
    return $list;
  }

public function processWorkspace( $pPath, $pFiles ) {

    // Para ir volcando los paquetes no procesados por alguna regla invalida
    $noimp = array();
    
    foreach( $pFiles as $file ) {
        // Intento determinar Ids de paquete y Macro a partir de atributos del xpdl a importar
        $xpdlId = UtilXpdl::getFileXpdlId($pPath.DIRECTORY_SEPARATOR.$this->getSubPathInWorkspace().DIRECTORY_SEPARATOR.$file);
        $xpdlName = UtilXpdl::getFileXpdlName($pPath.DIRECTORY_SEPARATOR.$this->getSubPathInWorkspace().DIRECTORY_SEPARATOR.$file);
        $xpdlMacroId = UtilXpdl::getFileXpdlMacroId($pPath.DIRECTORY_SEPARATOR.$this->getSubPathInWorkspace().DIRECTORY_SEPARATOR.$file);
        $xpdlMacroName = UtilXpdl::getFileXpdlMacroName($file);
        $content = file_get_contents($pPath.DIRECTORY_SEPARATOR.$this->getSubPathInWorkspace().DIRECTORY_SEPARATOR.$file);

        // Intento recuperar Macro si ya estuviese almacenado. Lo determino por:
        //  1- el macro Id como atributo extendido en el xpdl
        //  2- el nombre de la subcarpeta que contiene el xpdl
        // (Prevalece 1 sobre 2)
        if( $xpdlMacroId>0 ) {
            $macro = Doctrine::getTable('Paquete')->find($xpdlMacroId);
        }
        else {
            $macro = Doctrine::getTable('Paquete')->findByNombre($xpdlMacroName);
            if( count($macro)>0 ) {
                $macro = $macro[0];
            }
            else {
                $macro = false;
            }
        }

        // Intento recuperar Paquete si ya estuviese almacenado
        $pack = Doctrine::getTable('Paquete')->find(substr($xpdlId,1)>0?substr($xpdlId,1):0); // Saco el guion bajo

        // REGLAS

        $err = array();

        // Valido esten sincronizados...
        if( $pack && $macro) {
            if( $pack->getRelPaquete()!=$macro->getId() ) {
                $err['file'] = $file;
                $err['error'] = 'El Macro Id '.$xpdlId.' informado no coincide con el ya vinculado al paquete';
            }
        }
        
        // Valido el paquete ya no exista por el nombre
        if( !$pack) {
            $packNbre = Doctrine::getTable('Paquete')->findByNombre($xpdlName);
            if( count($packNbre)>0 ) {
                $err['file'] = $file;
                $err['error'] = 'Ya existe un Paquete de nombre '.$xpdlName.' pero con distinto ID';
            }
        }

        // CONTINUO SI SE PASARON TODAS LAS REGLAS

        if( count($err)==0 ) {
            // Creo el macro si aún no existe
            if( !$macro ) {
                $macro = new Paquete();
                $macro->setNombre($xpdlMacroName);
                $macro->setRelOrganizacion( $this->getRelOrganizacion() );
                $macro->save();
            }
            // Actualizo el nombre del Macro si fuese cambiado
            if( $macro->getNombre()!=$xpdlMacroName ) {
                $macro->setNombre($xpdlMacroName);
                $macro->save();
            }

            // Creo el paquete si aún no existe y actualizo
            if( !$pack ) {
                $pack = new Paquete();
                $pack->setRelPaquete($macro->getId());
            }
            $pack->setNombre($xpdlName);
            $pack->setXpdl($content);
            $pack->setRelOrganizacion( $this->getRelOrganizacion() );
            $pack->save();
            $pack->updateXpdlPackage(); // Para que ponga en el xpdl como id el del objeto paquete
            $pack->syncProcess();
        }
        else {
            $noimp[] = $err;
        }
    }
    return $noimp;
}


}